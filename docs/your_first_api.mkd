Building your first API
=======================

This is a guide to get you started with the Consumer Reports On-demand Container
Service, or `CR-ocs`.  It will help you write your first descriptor file.

You should understand the [design](./design_doc.mkd) of the system and the file
formats used before you begin.  The most important pieces:

 * The data exchange format with CR-ocs itself is *edn*
 * The data exchange format of the hosted APIs is the [universal json response format](./design_doc.mkd#default-output-format), or *JSON* for short
 * An API is described in a descriptor file
 * If you plan on upserting over HTTP, it's easier to build your descriptor in
   a payload format.

It also important to note that the terms *service*, *server*, *container* are all used interchangeably.


## Up and running

In a dedicated console/terminal window, start the service by typing the following command:

    lein run

If you don't have Leiningen installed, you can start the CR-ocs server with the `./server.sh` command instead.


## An accounts system

Let's build a system to handle basic user accounts and items those users own.

With this simple goal statement, we can already envision some pieces of the
data model and even some URLs that might appear in the RESTful API.

Our data model needs to handle:

 * Items (with item IDs, names, and descriptions)
 * Users (with user IDs, emails, and a list of items they own)

And we might have URLs that:

 * Fetch all items in the system
 * Fetch all users in the system
 * Fetch a user given their user ID
 * Fetch a user's owned-item list given their user ID
 * etc.


### Building the data model

Data models are defined with a schema.  You may split your schema up into
logic pieces that map directly to your application domain.  In our example,
we'll define part of the schema for Items, and another part for Users.

Since we'll be upserting our API over HTTP to the container, it's best to build
using the `payload` format.

```clojure
{
  :descriptor {:accounts {}}
  :app-name :accounts
  :version [:v1]
}
```

This says we're building the "accounts" API, and when we upsert to the service,
we should upload version "v1", which we haven't defined yet.

A descriptor file can define multiple APIs, and multiple versions of those APIs.
Developers are free to evolve these as needed.

The first component of a schema is defining its normalized, master form.  That's
done using the `:norms` entry.  In this map, we'll define attributes for Items
and Users.  You'll notice that the Users schema requires the Items schema, so
that we can describe a user's owned items.  You'll also notice that attributes
of a given entity are defined in terms of database transactions (*txes*) that
describe them.

```clojure
{
  :descriptor {:accounts {
                 :norms {:accounts/item-schema {
                           :txes [#cr-ocs/short-schema-tx [[:item/itemId :one :long :unique "The unique identifier for an item"]
                                                           [:item/name :one :string "The name of an item"]
                                                           [:item/description :one :string :fulltext "A short description of the item"]]]}
                         :accounts/user-schema {
                           :requires [:accounts/item-schema]
                           :txes [#cr-ocs/short-schema-tx [[:user/userId :one :long :unique "The unique identifier for a user"]
                                                           [:user/email :one :string :unique "The email address for a given user"]
                                                           [:user/items :many :ref "The collection of items a user owns"]]]}}}}
  :app-name :accounts
  :version [:v1]
}
```

CR-ocs offers a shorthand for defining Datomic schema transactions with the
literal tag `#cr-ocs/short-schema-tx`.  This tag marks a vector of vectors.
Each subvector defines an attribute, its cardinality, its type, an
optional qualifier (unique, index, or fulltext), and a doc string.  Attribute
names are *namespaced* with the entity name to which they apply.
The optional qualifiers let you mark attributes that have `:unique` values,
that the DB should `:index`, or that allow for `:fulltext` search.  `:fulltext`
also implies `:index`.  You can also say an entity's unique `:identity` can be
determined by an attribute, which is useful when you want to ensure an entity
can be upserted (`user_id`), but not when you want to avoiding adding a new
user that already exists (say, given their `email` - a `:unique` attribute).

Even though the short-schema version covers most of the use cases you'll need,
you're always free to use full Datomic [schema](http://docs.datomic.com/schema.html)
definitions like:

```clojure
{:db/id #db/id[:db.part/db]
 :db/ident :item/name
 :db/valueType :db.type/string
 :db/cardinality :db.cardinality/one
 :db/doc "The name of an item"
 :db.install/_attribute :db.part/db}
```


### Making it RESTful

We can now begin building out an HTTP Restful API for our data model.  This will
let third-party application and other internal services make use of our data.

Routes get defined with URL strings, HTTP verbs (get, post, etc), and action
literals.  The foundation of CR-ocs routing is based on [Pedestal's capabilities](https://github.com/pedestal/pedestal/blob/master/guides/documentation/service-routing.md),
but with care given to represent routes in an external data file (like our descriptor).

Below we've added a route to our descriptor that gives some information about our API:

```clojure
{
  :descriptor {:accounts {
                 :norms {:accounts/item-schema {
                           :txes [#cr-ocs/short-schema-tx [[:item/itemId :one :long :unique "The unique identifier for an item"]
                                                           [:item/name :one :string "The name of an item"]
                                                           [:item/description :one :string :fulltext "A short description of the item"]]]}
                         :accounts/user-schema {
                           :requires [:accounts/item-schema]
                           :txes [#cr-ocs/short-schema-tx [[:user/userId :one :long :unique "The unique identifier for a user"]
                                                           [:user/email :one :string :unique "The email address for a given user"]
                                                           [:user/items :many :ref "The collection of items a user owns"]]]}}
                 ;; API Versions
                 ;; -------------
                 :v1 {:routes [["/about" {:get #cr-ocs/respond {:name :accounts-v1/about-response
                                                                :body "General User and Item Information"}}]]}}}
  :app-name :accounts
  :version [:v1]
}
```

Routes are defined as vectors of vectors.  Each subvector defines a single
route/path, and then a map of HTTP verbs to action literals.  Here we see that
*GET /api/accounts/v1/about* will respond with a text body.  Also notice that
every action literal needs a unique `:name` associated with it.
There are five action literals:

 * `#cr-ocs/respond` - respond with static data, optionally formatted as JSON
 * `#cr-ocs/redirect` - redirect an incoming request to a different URL
   * Not covered in this guide, please see the [sample descriptor](../config/sample_descriptor.edn) for usage.
 * `#cr-ocs/query` - respond with the results of a database query
 * `#cr-ocs/transact` - add/update data in the database
 * `#cr-ocs/validate` - validate that data conforms to a set of rules
   * This action literal is currently turned off and not usable

Below we've added the schemas that our API uses and tell the container to
forward some HTTP request headers with every response.

```clojure
{
  :descriptor {:accounts {
                 :norms {:accounts/item-schema {
                           :txes [#cr-ocs/short-schema-tx [[:item/itemId :one :long :unique "The unique identifier for an item"]
                                                           [:item/name :one :string "The name of an item"]
                                                           [:item/description :one :string :fulltext "A short description of the item"]]]}
                         :accounts/user-schema {
                           :requires [:accounts/item-schema]
                           :txes [#cr-ocs/short-schema-tx [[:user/userId :one :long :unique "The unique identifier for a user"]
                                                           [:user/email :one :string :unique "The email address for a given user"]
                                                           [:user/items :many :ref "The collection of items a user owns"]]]}}
                 ;; API Versions
                 ;; -------------
                 :v1 {:routes [["/about" {:get #cr-ocs/respond {:name :accounts-v1/about-response
                                                                :body "General User and Item Information"}}]]
                      :schemas [:accounts/user-schema]
                      :forward-headers ["crrequest-id"]}}}
  :app-name :accounts
  :version [:v1]
}
```

Since our API is only about providing operations for user details and accounts,
we only need to depend on/declare the user schema.  Above we're saying that
version *v1* of our *accounts* API uses the *user-schema*, and to forward the
*crrequest-id* header from every request to every response.  This HTTP header
is used to trace and debug requests to the service (and is automatically added
if it's not sent in).  APIs can depend on any number of schemas.  You should
feel free to grow and evolved your normalized schema `:norms` and add
them to you APIs `:schema` dependencies. This is one of the major benefits
of Datomic.


#### Upserting your new API

Sending this payload to the service will call the container to upsert it -
Update it if it exists, insert it if its new.  There's a client script
to make the process as straight forward as possible (as long as your using the
default container settings).

 1. Save the descriptor text shown above into a file named `config/my-new-payload.edn`
 2. Run: `./client.sh config/my-new-payload.edn`, to upsert your payload.
 3. Run: `./client` to see the latest routes

You can also use your browser and go to [http://127.0.0.1:8080/api](http://127.0.0.1:8080/api)


#### Handling Parameters

HTTP parameters are bound in a route's action literal, using the `:params`
keyword.  They can come in various forms, extracted from: an edn payload
(POST), a JSON payload (POST), Form data (POST), querystring arguments (GET),
and URL parameters.  Parameters are resolved with an order of precedence, as listed below:

 * edn POST payloads override
 * JSON POST payloads override
 * POST Form data payloads override
 * QueryString args override
 * URL parameters

Let's look at them from the bottom up.

URL parameters bind a single value from a URL to a symbol name in your action literal.
Here's an example with a URL parameter:

```clojure
{
  :descriptor {:accounts {
                 :norms {:accounts/item-schema {
                           :txes [#cr-ocs/short-schema-tx [[:item/itemId :one :long :unique "The unique identifier for an item"]
                                                           [:item/name :one :string "The name of an item"]
                                                           [:item/description :one :string :fulltext "A short description of the item"]]]}
                         :accounts/user-schema {
                           :requires [:accounts/item-schema]
                           :txes [#cr-ocs/short-schema-tx [[:user/userId :one :long :unique "The unique identifier for a user"]
                                                           [:user/email :one :string :unique "The email address for a given user"]
                                                           [:user/items :many :ref "The collection of items a user owns"]]]}}
                 ;; API Versions
                 ;; -------------
                 :v1 {:routes [["/about" {:get #cr-ocs/respond {:name :accounts-v1/about-response
                                                                :body "General User and Item Information"}}]
                               ["/about/:your-name" {:get #cr-ocs/respond {:name :accounts-v1/about-yourname
                                                                           :params [your-name]
                                                                           :body your-name}}]]
                      :schemas [:accounts/user-schema]
                      :forward-headers ["crrequest-id"]}}}
  :app-name :accounts
  :version [:v1]
}
```

In this trivial example we bind part of the URL to the symbol `your-name` and
return it as the body of our response.  URL parameters are always string values.
Upsert your descriptor and [see for yourself](http://127.0.0.1:8080/about/paul).
Let's see how we might take multiple parameters for a given route.

Querystring args are typically used for filtering the result of returned data.
Here's an example were we'll return a JSON response for all of our expected query args

```clojure
{
  :descriptor {:accounts {
                 :norms {:accounts/item-schema {
                           :txes [#cr-ocs/short-schema-tx [[:item/itemId :one :long :unique "The unique identifier for an item"]
                                                           [:item/name :one :string "The name of an item"]
                                                           [:item/description :one :string :fulltext "A short description of the item"]]]}
                         :accounts/user-schema {
                           :requires [:accounts/item-schema]
                           :txes [#cr-ocs/short-schema-tx [[:user/userId :one :long :unique "The unique identifier for a user"]
                                                           [:user/email :one :string :unique "The email address for a given user"]
                                                           [:user/items :many :ref "The collection of items a user owns"]]]}}
                 ;; API Versions
                 ;; -------------
                 :v1 {:routes [["/about" {:get #cr-ocs/respond {:name :accounts-v1/about-response
                                                                :body "General User and Item Information"}}]
                               ["/about/:your-name" {:get #cr-ocs/respond {:name :accounts-v1/about-yourname
                                                                           :params [your-name]
                                                                           :body your-name}}]
                               ["/aboutquery" {:get #cr-ocs/respond {:name :accounts-v1/about-query
                                                                           :params [one-thing another-thing]
                                                                           :body {:first-param one-thing
                                                                                  :second-param another-thing}}}]]
                      :schemas [:accounts/user-schema]
                      :forward-headers ["crrequest-id"]}}}
  :app-name :accounts
  :version [:v1]
}
```

When you upsert and browse to [the new url](http://127.0.0.1:8080/aboutquery?one-thing=hello&another-thing=world), you'll
notice that the response that comes back is JSON, not text like the other `respond`
actions we specified.  When the body of a response is not a string, it's
automatically converted into JSON.

You can also force string bodies conform to that format.  Let's update our old
*/about* page to return JSON with `:enforce-format true`:

```clojure
{
  :descriptor {:accounts {
                 :norms {:accounts/item-schema {
                           :txes [#cr-ocs/short-schema-tx [[:item/itemId :one :long :unique "The unique identifier for an item"]
                                                           [:item/name :one :string "The name of an item"]
                                                           [:item/description :one :string :fulltext "A short description of the item"]]]}
                         :accounts/user-schema {
                           :requires [:accounts/item-schema]
                           :txes [#cr-ocs/short-schema-tx [[:user/userId :one :long :unique "The unique identifier for a user"]
                                                           [:user/email :one :string :unique "The email address for a given user"]
                                                           [:user/items :many :ref "The collection of items a user owns"]]]}}
                 ;; API Versions
                 ;; -------------
                 :v1 {:routes [["/about" {:get #cr-ocs/respond {:name :accounts-v1/about-response
                                                                :enforce-format true
                                                                :body "General User and Item Information"}}]
                               ["/about/:your-name" {:get #cr-ocs/respond {:name :accounts-v1/about-yourname
                                                                           :params [your-name]
                                                                           :body your-name}}]
                               ["/aboutquery" {:get #cr-ocs/respond {:name :accounts-v1/about-query
                                                                           :params [one-thing another-thing]
                                                                           :body {:first-param one-thing
                                                                                  :second-param another-thing}}}]]
                      :schemas [:accounts/user-schema]
                      :forward-headers ["crrequest-id"]}}}
  :app-name :accounts
  :version [:v1]
}
```

**Working with POST data**

All of the POST params work the same way.  Suppose you have a JSON payload posted
to your endpoint like:

```json
{
  "a" : "Hello",
  "b" : "World"
}
```

You could bind parameters `a` and `b` like:

```clojure
:params [a b]
```

and their values would be "Hello" and "World", respectively.


#### A dangerous truth

So far, we've lead you to believe that action literals are *purely* data and that
no code whatsoever can ever be used within a literal.

That's not true.

During the symbol escaping process, all function that are part of Clojure's core
will correctly resolve, unless you have bound a symbol of the same name in `:params`.

This means we can add some basic functionality to our `#respond` actions.
Let's update our url-param route to print a more interesting string using
Clojure's `(str ...)` function.

```clojure
{
  :descriptor {:accounts {
                 :norms {:accounts/item-schema {
                           :txes [#cr-ocs/short-schema-tx [[:item/itemId :one :long :unique "The unique identifier for an item"]
                                                           [:item/name :one :string "The name of an item"]
                                                           [:item/description :one :string :fulltext "A short description of the item"]]]}
                         :accounts/user-schema {
                           :requires [:accounts/item-schema]
                           :txes [#cr-ocs/short-schema-tx [[:user/userId :one :long :unique "The unique identifier for a user"]
                                                           [:user/email :one :string :unique "The email address for a given user"]
                                                           [:user/items :many :ref "The collection of items a user owns"]]]}}
                 ;; API Versions
                 ;; -------------
                 :v1 {:routes [["/about" {:get #cr-ocs/respond {:name :accounts-v1/about-response
                                                                :enforce-format true
                                                                :body "General User and Item Information"}}]
                               ["/about/:your-name" {:get #cr-ocs/respond {:name :accounts-v1/about-yourname
                                                                           :params [your-name]
                                                                           :body (str "You said your name was: " your-name)}}]
                               ["/aboutquery" {:get #cr-ocs/respond {:name :accounts-v1/about-query
                                                                           :params [one-thing another-thing]
                                                                           :body {:first-param one-thing
                                                                                  :second-param another-thing}}}]]
                      :schemas [:accounts/user-schema]
                      :forward-headers ["crrequest-id"]}}}
  :app-name :accounts
  :version [:v1]
}
```

With great power comes great responsibility - bending this ability is dangerous
and can cause the container to crash, but in a pinch it can allow you to shape an
API to meet your needs.


#### Getting data in with `transact`

In addition to rendering content, the CR-ocs system also provides a `#transact`
action allowing the storage of incomming POST data.  Observe the following addition
to the system descriptor:

```clojure
{
  :descriptor {:accounts {
                 :norms {:accounts/item-schema {
                           :txes [#cr-ocs/short-schema-tx [[:item/itemId :one :long :unique "The unique identifier for an item"]
                                                           [:item/name :one :string "The name of an item"]
                                                           [:item/description :one :string :fulltext "A short description of the item"]]]}
                         :accounts/user-schema {
                           :requires [:accounts/item-schema]
                           :txes [#cr-ocs/short-schema-tx [[:user/userId :one :long :unique "The unique identifier for a user"]
                                                           [:user/email :one :string :unique "The email address for a given user"]
                                                           [:user/items :many :ref "The collection of items a user owns"]]]}}
                 ;; API Versions
                 ;; -------------
                 :v1 {:routes [["/about" {:get #cr-ocs/respond {:name :accounts-v1/about-response
                                                                :enforce-format true
                                                                :body "General User and Item Information"}}]
                               ["/about/:your-name" {:get #cr-ocs/respond {:name :accounts-v1/about-yourname
                                                                           :params [your-name]
                                                                           :body (str "You said your name was: " your-name)}}]
                               ["/aboutquery" {:get #cr-ocs/respond {:name :accounts-v1/about-query
                                                                           :params [one-thing another-thing]
                                                                           :body {:first-param one-thing
                                                                                  :second-param another-thing}}}]

                               ["/user" {:post #cr-ocs/transact {:name :accounts-v1/user-create
                                                                 :properties [
                                                                   :db/id
                                                                   :user/userId
                                                                   :user/email]}}]]

                      :schemas [:accounts/user-schema]
                      :forward-headers ["crrequest-id"]}}}
  :app-name :accounts
  :version [:v1]
}
```

The added `#transact` literal shown above consists of a single element
`:properties`.  The `:properties` field describes the whitelisted properties
accepted in a set of incoming POST data.  The properties `:user/userId` and
`:user/userEmail` are fairly self-explanatory, but the `:db/id` property is
handled specially.  That is, the `:db/id` key signifies if the incoming data
refers to existing entities in the CR-ocs database, or to new entities.  For
example, consider the following JSON corresponding to incoming POST data:

```json
{ "payload" :
  [{
    "user/userId" : 42,
    "user/email" : "user@example.com"
  }]
}
```

The JSON packet above, because it does not contain a `:db/id` field refers to a
new entity and the return value from the CR-ocs service will return its newly
created `:db/id`.  On the other hand, the following JSON refers to an existing
entity in the database:

```json
{ "payload" :
  [{
    "db/id" : 100,
    "user/userId" : 9,
    "user/email" : "user9@example.com"
  }]
}
```

Because the `:db/id` field is set to a value the CR-ocs system will attempt to
resolve the entity in the database before transacting the data.  Obviously, if
no such entity exists then a failure will occur, thus notifying the calling
client.

One final way to refer to existing entities is to set the value at the `:db/id`
field to correspond to a unique value for the entity in question.  For example:

```json
{ "payload" :
  [{
    "db/id" : ["user/userId", 9],
    "user/email" : "user9@example.com"
  }]
}
```

Because the User IDs are unique to each user, they can be used to demarcate a
unique entity in the database for the purposes of transcting associated data.


#### Getting data out with `query`

It makes sense that if the CR-ocs system allows the insertion of new data that
the data availble be accessible as well.  Indeed, the `#query` action provides
the mechanism for defining service routes that return data based on Datalog
queries.  Observe the following addition to the system descriptor:

```clojure
{
  :descriptor {:accounts {
                 :norms {:accounts/item-schema {
                           :txes [#cr-ocs/short-schema-tx [[:item/itemId :one :long :unique "The unique identifier for an item"]
                                                           [:item/name :one :string "The name of an item"]
                                                           [:item/description :one :string :fulltext "A short description of the item"]]]}
                         :accounts/user-schema {
                           :requires [:accounts/item-schema]
                           :txes [#cr-ocs/short-schema-tx [[:user/userId :one :long :unique "The unique identifier for a user"]
                                                           [:user/email :one :string :unique "The email address for a given user"]
                                                           [:user/items :many :ref "The collection of items a user owns"]]]}}
                 ;; API Versions
                 ;; -------------
                 :v1 {:routes [["/about" {:get #cr-ocs/respond {:name :accounts-v1/about-response
                                                                :enforce-format true
                                                                :body "General User and Item Information"}}]
                               ["/about/:your-name" {:get #cr-ocs/respond {:name :accounts-v1/about-yourname
                                                                           :params [your-name]
                                                                           :body (str "You said your name was: " your-name)}}]
                               ["/aboutquery" {:get #cr-ocs/respond {:name :accounts-v1/about-query
                                                                           :params [one-thing another-thing]
                                                                           :body {:first-param one-thing
                                                                                  :second-param another-thing}}}]

                               ["/user" {:post #cr-ocs/transact {:name :accounts-v1/user-create
                                                                 :properties [
                                                                   :db/id
                                                                   :user/userId
                                                                   :user/email]}
                                         :get #cr-ocs/query {:name :accounts-v1/user-page
                                                              :params [email]
                                                              :query
                                                              [:find ?e
                                                               :in $ ?email
                                                               :where
                                                               [?e :user/email ?email]]}}]]

                      :schemas [:accounts/user-schema]
                      :forward-headers ["crrequest-id"]}}}
  :app-name :accounts
  :version [:v1]
}
```

One query routes is defined above called `/user`.  This route allows the look up
of database entity information based on an email supplied as a URL parameter (e.g.
http://example.com/user?email=user@example.com).  The `#query` action
contains two fundametal properties, `:params` and `:query` (we'll discuss a
3rd, optional, property below).  The `:params` properties defines the accepted keyed
data names that are used as external arguments to the query to resolve those listed
parameters to the incoming values.  The `:params` field can be left empty to signify
that the query does not accept arguments.  The `:query` property contains the actual
datalog query as described in a different document in this repository.

One limitation of providing query parameters as URL arguments or path parameters
is that only string types are shuttled across to the server.  Often it's useful
to refer to arguments that are other useful types, numbers are one such possibility.
Observe our next change to the descriptor below:

```clojure
{
  :descriptor {:accounts {
                 :norms {:accounts/item-schema {
                           :txes [#cr-ocs/short-schema-tx [[:item/itemId :one :long :unique "The unique identifier for an item"]
                                                           [:item/name :one :string "The name of an item"]
                                                           [:item/description :one :string :fulltext "A short description of the item"]]]}
                         :accounts/user-schema {
                           :requires [:accounts/item-schema]
                           :txes [#cr-ocs/short-schema-tx [[:user/userId :one :long :unique "The unique identifier for a user"]
                                                           [:user/email :one :string :unique "The email address for a given user"]
                                                           [:user/items :many :ref "The collection of items a user owns"]]]}}
                 ;; API Versions
                 ;; -------------
                 :v1 {:routes [["/about" {:get #cr-ocs/respond {:name :accounts-v1/about-response
                                                                :enforce-format true
                                                                :body "General User and Item Information"}}]
                               ["/about/:your-name" {:get #cr-ocs/respond {:name :accounts-v1/about-yourname
                                                                           :params [your-name]
                                                                           :body (str "You said your name was: " your-name)}}]
                               ["/aboutquery" {:get #cr-ocs/respond {:name :accounts-v1/about-query
                                                                           :params [one-thing another-thing]
                                                                           :body {:first-param one-thing
                                                                                  :second-param another-thing}}}]

                               ["/user" {:post #cr-ocs/transact {:name :accounts-v1/user-create
                                                                 :properties [
                                                                   :db/id
                                                                   :user/userId
                                                                   :user/email]}
                                         :get #cr-ocs/query {:name :accounts-v1/user-page
                                                              :params [email]
                                                              :query
                                                              [:find ?e
                                                               :in $ ?email
                                                               :where
                                                               [?e :user/email ?email]]}}]
                               ["/user/:id" {:get #cr-ocs/query {:name :accounts-v1/user-id-page
                                                                :params [id]
                                                                :edn-coerce [id]
                                                                :query
                                                                 [:find ?e
                                                                  :in $ ?id
                                                                  :where
                                                                  [?e :user/userId ?id]]}}]]

                      :schemas [:accounts/user-schema]
                      :forward-headers ["crrequest-id"]}}}
  :app-name :accounts
  :version [:v1]
}
```

The second route, called `/user/:id` allows the a similar information lookup, but instead supplied
as a path parameter (e.g. http://example.com/user/id). By default the `:id` parameter would be
a string value, but by using the `:edn-coerce` property of the `#query` action we tell CR-ocs to
attempt to parse the string as a valid EDN data type.  Therefore, when clients hit the URL
bound to that query the proper types will match (i.e. the DB expects integer IDs, not string IDs).

**Querying `or` and other constants**

It's often useful to model a query that match against anything within a given
data set, for example, *Give me all users whose email is in `["jane@domain.com", "bill@domain.com"]`*

In Datomic this is called a "parameterized in/or query," and it's achieved by
binding the names with the `:in` clause.  To do this, we supply additional
constant data to the CR-ocs query with the `:constants` option.  An example
can illustrate - observe our last change to the schema below:

```clojure
{
  :descriptor {:accounts {
                 :norms {:accounts/item-schema {
                           :txes [#cr-ocs/short-schema-tx [[:item/itemId :one :long :unique "The unique identifier for an item"]
                                                           [:item/name :one :string "The name of an item"]
                                                           [:item/description :one :string :fulltext "A short description of the item"]]]}
                         :accounts/user-schema {
                           :requires [:accounts/item-schema]
                           :txes [#cr-ocs/short-schema-tx [[:user/userId :one :long :unique "The unique identifier for a user"]
                                                           [:user/email :one :string :unique "The email address for a given user"]
                                                           [:user/items :many :ref "The collection of items a user owns"]]]}}
                 ;; API Versions
                 ;; -------------
                 :v1 {:routes [["/about" {:get #cr-ocs/respond {:name :accounts-v1/about-response
                                                                :enforce-format true
                                                                :body "General User and Item Information"}}]
                               ["/about/:your-name" {:get #cr-ocs/respond {:name :accounts-v1/about-yourname
                                                                           :params [your-name]
                                                                           :body (str "You said your name was: " your-name)}}]
                               ["/aboutquery" {:get #cr-ocs/respond {:name :accounts-v1/about-query
                                                                           :params [one-thing another-thing]
                                                                           :body {:first-param one-thing
                                                                                  :second-param another-thing}}}]

                               ["/user" {:post #cr-ocs/transact {:name :accounts-v1/user-create
                                                                 :properties [
                                                                   :db/id
                                                                   :user/userId
                                                                   :user/email]}
                                         :get #cr-ocs/query {:name :accounts-v1/user-page
                                                              :params [email]
                                                              :query
                                                              [:find ?e
                                                               :in $ ?email
                                                               :where
                                                               [?e :user/email ?email]]}}]
                               ["/user/:id" {:get #cr-ocs/query {:name :accounts-v1/user-id-page
                                                                :params [id]
                                                                :edn-coerce [id]
                                                                :query
                                                                 [:find ?e
                                                                  :in $ ?id
                                                                  :where
                                                                  [?e :user/userId ?id]]}}]
                               ["/special-users" {:get #cr-ocs/query {:name :accounts-v1/user-id-page
                                                                      :params []
                                                                      :constants [["jane@domain.com" "bill@domain.com"]]
                                                                :query
                                                                 [:find ?e
                                                                  :in $ [?email ...]
                                                                  :where
                                                                  [?e :user/email ?email]]}}]]

                      :schemas [:accounts/user-schema]
                      :forward-headers ["crrequest-id"]}}}
  :app-name :accounts
  :version [:v1]
}
```

These features can be combined in anyway to produce a target API.

Good luck and get building!

